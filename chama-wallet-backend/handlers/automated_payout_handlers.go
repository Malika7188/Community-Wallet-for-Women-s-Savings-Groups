package handlers

import (
	"fmt"

	"github.com/gofiber/fiber/v2"

	"chama-wallet-backend/database"
	"chama-wallet-backend/models"
	"chama-wallet-backend/services"
)

// GetPendingAutomaticPayouts returns all pending automatic payouts for admin approval
func GetPendingAutomaticPayouts(c *fiber.Ctx) error {
	user := c.Locals("user").(models.User)

	// Get groups where user is admin
	var adminGroups []string
	database.DB.Model(&models.Member{}).
		Where("user_id = ? AND role IN ? AND status = ?", 
			user.ID, []string{"creator", "admin"}, "approved").
		Pluck("group_id", &adminGroups)

	if len(adminGroups) == 0 {
		return c.JSON([]models.PayoutRequest{})
	}

	// Get pending automatic payouts for these groups
	var payouts []models.PayoutRequest
	err := database.DB.Where("group_id IN ? AND status = ? AND auto_generated = ?", 
		adminGroups, "pending", true).
		Preload("Group").
		Preload("Recipient").
		Order("created_at ASC").
		Find(&payouts).Error

	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": err.Error()})
	}

	return c.JSON(payouts)
}

// ApproveAutomaticPayout handles single admin approval and execution of automatic payouts
func ApproveAutomaticPayout(c *fiber.Ctx) error {
	payoutID := c.Params("id")
	user := c.Locals("user").(models.User)

	var payload struct {
		AdminSecretKey string `json:"admin_secret_key"`
		Approved       bool   `json:"approved"`
	}

	if err := c.BodyParser(&payload); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request body"})
	}

	// Get payout details
	var payout models.PayoutRequest
	if err := database.DB.Where("id = ?", payoutID).
		Preload("Group").
		Preload("Recipient").
		First(&payout).Error; err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "Payout not found"})
	}

	// Validate this is an automatic payout
	if !payout.AutoGenerated {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "This endpoint only handles automatic payouts",
		})
	}

	// Validate user is designated admin for this group
	aps := &services.AutomatedPayoutService{}
	designatedAdmin, err := aps.GetDesignatedAdmin(payout.GroupID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to get designated admin",
		})
	}

	if designatedAdmin.UserID != user.ID {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Only the designated admin can approve automatic payouts",
		})
	}

	// Handle rejection
	if !payload.Approved {
		database.DB.Model(&payout).Update("status", "rejected")
		
		// Notify members about rejection
		var members []models.Member
		database.DB.Where("group_id = ? AND status = ?", payout.GroupID, "approved").Find(&members)
		
		for _, member := range members {
			services.CreateNotification(
				member.UserID,
				payout.GroupID,
				"payout_rejected",
				"Payout Rejected",
				fmt.Sprintf("Round %d payout has been rejected by admin", payout.Round),
			)
		}

		return c.JSON(fiber.Map{"message": "Payout rejected successfully"})
	}

	// Validate admin secret key is provided for approval
	if payload.AdminSecretKey == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Admin secret key is required for payout execution",
		})
	}

	// Execute the automatic payout
	if err := aps.ExecuteAutomaticPayout(payoutID, payload.AdminSecretKey); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("Payout execution failed: %v", err),
		})
	}

	return c.JSON(fiber.Map{
		"message":   "Payout approved and executed successfully",
		"payout_id": payoutID,
		"status":    "completed",
	})
}

// TriggerAutomaticPayoutCheck manually triggers the automatic payout check
func TriggerAutomaticPayoutCheck(c *fiber.Ctx) error {
	user := c.Locals("user").(models.User)

	// Verify user is admin of at least one group
	var adminCount int64
	database.DB.Model(&models.Member{}).
		Where("user_id = ? AND role IN ? AND status = ?", 
			user.ID, []string{"creator", "admin"}, "approved").
		Count(&adminCount)

	if adminCount == 0 {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Only group admins can trigger payout checks",
		})
	}

	aps := &services.AutomatedPayoutService{}
	if err := aps.CheckAndCreateAutomaticPayouts(); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("Failed to check automatic payouts: %v", err),
		})
	}

	return c.JSON(fiber.Map{
		"message": "Automatic payout check completed successfully",
	})
}

// GetPayoutStatus returns detailed status of a specific payout
func GetPayoutStatus(c *fiber.Ctx) error {
	payoutID := c.Params("id")
	user := c.Locals("user").(models.User)

	var payout models.PayoutRequest
	if err := database.DB.Where("id = ?", payoutID).
		Preload("Group").
		Preload("Recipient").
		Preload("Approvals.Admin").
		First(&payout).Error; err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "Payout not found"})
	}

	// Check if user has access to this payout
	var member models.Member
	if err := database.DB.Where("group_id = ? AND user_id = ? AND status = ?",
		payout.GroupID, user.ID, "approved").First(&member).Error; err != nil {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{"error": "Access denied"})
	}

	// Get round status
	var roundStatus models.RoundStatus
	database.DB.Where("group_id = ? AND round = ?", payout.GroupID, payout.Round).First(&roundStatus)

	return c.JSON(fiber.Map{
		"payout":       payout,
		"round_status": roundStatus,
		"is_admin":     member.Role == "creator" || member.Role == "admin",
	})
}