package services

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/stellar/go/keypair"

	"chama-wallet-backend/database"
	"chama-wallet-backend/models"
)

// AutomatedPayoutService handles the automated payout logic
type AutomatedPayoutService struct{}

// CheckAndCreateAutomaticPayouts checks all active groups for completed rounds and creates payouts
func (aps *AutomatedPayoutService) CheckAndCreateAutomaticPayouts() error {
	fmt.Println("üîÑ Starting automated payout check...")

	var activeGroups []models.Group
	if err := database.DB.Where("status = ?", "active").Find(&activeGroups).Error; err != nil {
		return fmt.Errorf("failed to fetch active groups: %w", err)
	}

	fmt.Printf("üìä Found %d active groups to check\n", len(activeGroups))

	for _, group := range activeGroups {
		if err := aps.processGroupPayouts(group); err != nil {
			fmt.Printf("‚ùå Error processing payouts for group %s: %v\n", group.Name, err)
			continue
		}
	}

	fmt.Println("‚úÖ Automated payout check completed")
	return nil
}

// processGroupPayouts handles payout logic for a specific group
func (aps *AutomatedPayoutService) processGroupPayouts(group models.Group) error {
	fmt.Printf("üîç Processing payouts for group: %s (Round %d)\n", group.Name, group.CurrentRound)

	// Get current round status
	var roundStatus models.RoundStatus
	if err := database.DB.Where("group_id = ? AND round = ?", group.ID, group.CurrentRound).
		First(&roundStatus).Error; err != nil {
		// Create round status if it doesn't exist
		if err := aps.createRoundStatus(group); err != nil {
			return fmt.Errorf("failed to create round status: %w", err)
		}
		// Fetch the newly created round status
		database.DB.Where("group_id = ? AND round = ?", group.ID, group.CurrentRound).First(&roundStatus)
	}

	// Check if all members have contributed
	if !aps.isRoundComplete(group.ID, group.CurrentRound) {
		fmt.Printf("‚è≥ Round %d not complete for group %s\n", group.CurrentRound, group.Name)
		return nil
	}

	// Check if payout already created for this round
	if roundStatus.PayoutCreated {
		fmt.Printf("‚ÑπÔ∏è Payout already created for round %d in group %s\n", group.CurrentRound, group.Name)
		return aps.checkExistingPayout(group, roundStatus)
	}

	// Create automatic payout
	return aps.createAutomaticPayout(group, roundStatus)
}

// isRoundComplete checks if all members have contributed for the current round
func (aps *AutomatedPayoutService) isRoundComplete(groupID string, round int) bool {
	var totalMembers int64
	database.DB.Model(&models.Member{}).
		Where("group_id = ? AND status = ?", groupID, "approved").
		Count(&totalMembers)

	var contributionsCount int64
	database.DB.Model(&models.RoundContribution{}).
		Where("group_id = ? AND round = ? AND status = ?", groupID, round, "confirmed").
		Count(&contributionsCount)

	fmt.Printf("üìä Round %d completion: %d/%d members contributed\n", round, contributionsCount, totalMembers)
	return contributionsCount >= totalMembers
}

// createAutomaticPayout creates a payout request when round is complete
func (aps *AutomatedPayoutService) createAutomaticPayout(group models.Group, roundStatus models.RoundStatus) error {
	fmt.Printf("üéØ Creating automatic payout for group %s, round %d\n", group.Name, group.CurrentRound)

	// Get designated recipient for this round
	recipient, err := aps.getDesignatedRecipient(group, group.CurrentRound)
	if err != nil {
		return fmt.Errorf("failed to get designated recipient: %w", err)
	}

	// Calculate total payout amount
	var totalReceived float64
	database.DB.Model(&models.RoundContribution{}).
		Where("group_id = ? AND round = ? AND status = ?", group.ID, group.CurrentRound, "confirmed").
		Select("COALESCE(SUM(amount), 0)").
		Scan(&totalReceived)

	fmt.Printf("üí∞ Total amount to payout: %.2f XLM to %s\n", totalReceived, recipient.User.Name)

	// Create payout request
	payoutRequest := models.PayoutRequest{
		ID:            uuid.NewString(),
		GroupID:       group.ID,
		RecipientID:   recipient.UserID,
		Amount:        totalReceived,
		Round:         group.CurrentRound,
		Status:        "pending",
		AutoGenerated: true,
		CreatedAt:     time.Now(),
	}

	if err := database.DB.Create(&payoutRequest).Error; err != nil {
		return fmt.Errorf("failed to create payout request: %w", err)
	}

	// Update round status
	database.DB.Model(&roundStatus).Updates(map[string]interface{}{
		"status":                   "ready_for_payout",
		"payout_created":           true,
		"designated_recipient_id":  recipient.ID,
	})

	// Notify designated admin about pending payout
	if err := aps.notifyDesignatedAdmin(group, payoutRequest, recipient); err != nil {
		fmt.Printf("‚ö†Ô∏è Warning: Failed to notify admin: %v\n", err)
	}

	fmt.Printf("‚úÖ Automatic payout created: %s\n", payoutRequest.ID)
	return nil
}

// getDesignatedRecipient determines who should receive the payout for this round
func (aps *AutomatedPayoutService) getDesignatedRecipient(group models.Group, round int) (models.Member, error) {
	// Parse payout order from JSON
	var payoutOrder []string
	if err := json.Unmarshal([]byte(group.PayoutOrder), &payoutOrder); err != nil {
		return models.Member{}, fmt.Errorf("failed to parse payout order: %w", err)
	}

	if len(payoutOrder) == 0 {
		return models.Member{}, fmt.Errorf("payout order is empty")
	}

	// Get recipient for this round (round is 1-indexed)
	recipientIndex := (round - 1) % len(payoutOrder)
	recipientUserID := payoutOrder[recipientIndex]

	// Find the member record
	var recipient models.Member
	if err := database.DB.Where("group_id = ? AND user_id = ? AND status = ?", 
		group.ID, recipientUserID, "approved").
		Preload("User").
		First(&recipient).Error; err != nil {
		return models.Member{}, fmt.Errorf("failed to find recipient member: %w", err)
	}

	fmt.Printf("üéØ Round %d recipient: %s (%s)\n", round, recipient.User.Name, recipient.User.Email)
	return recipient, nil
}

// notifyDesignatedAdmin notifies the designated admin about pending payout
func (aps *AutomatedPayoutService) notifyDesignatedAdmin(group models.Group, payout models.PayoutRequest, recipient models.Member) error {
	// Get designated admin (creator for now, can be enhanced to rotate)
	var admin models.Member
	if err := database.DB.Where("group_id = ? AND role = ? AND status = ?", 
		group.ID, "creator", "approved").
		Preload("User").
		First(&admin).Error; err != nil {
		// Fallback to any admin
		if err := database.DB.Where("group_id = ? AND role = ? AND status = ?", 
			group.ID, "admin", "approved").
			Preload("User").
			First(&admin).Error; err != nil {
			return fmt.Errorf("no admin found for group")
		}
	}

	// Create notification
	return CreateNotification(
		admin.UserID,
		group.ID,
		"automatic_payout_ready",
		"Automatic Payout Ready",
		fmt.Sprintf("Round %d is complete. Payout of %.2f XLM to %s is ready for approval.", 
			payout.Round, payout.Amount, recipient.User.Name),
	)
}

// createRoundStatus creates initial round status for a group
func (aps *AutomatedPayoutService) createRoundStatus(group models.Group) error {
	var totalMembers int64
	database.DB.Model(&models.Member{}).
		Where("group_id = ? AND status = ?", group.ID, "approved").
		Count(&totalMembers)

	roundStatus := models.RoundStatus{
		ID:                uuid.NewString(),
		GroupID:           group.ID,
		Round:             group.CurrentRound,
		TotalRequired:     group.ContributionAmount * float64(totalMembers),
		TotalReceived:     0,
		ContributorsCount: 0,
		RequiredCount:     int(totalMembers),
		Status:            "collecting",
		CreatedAt:         time.Now(),
		UpdatedAt:         time.Now(),
	}

	return database.DB.Create(&roundStatus).Error
}

// checkExistingPayout checks and processes existing payout if needed
func (aps *AutomatedPayoutService) checkExistingPayout(group models.Group, roundStatus models.RoundStatus) error {
	var payout models.PayoutRequest
	if err := database.DB.Where("group_id = ? AND round = ? AND auto_generated = ?", 
		group.ID, group.CurrentRound, true).First(&payout).Error; err != nil {
		return nil // No existing payout found
	}

	// Check if payout is completed and advance round if needed
	if payout.Status == "completed" && !roundStatus.PayoutCompleted {
		return aps.advanceToNextRound(group)
	}

	return nil
}

// advanceToNextRound moves the group to the next contribution round
func (aps *AutomatedPayoutService) advanceToNextRound(group models.Group) error {
	fmt.Printf("üîÑ Advancing group %s to next round\n", group.Name)

	nextRound := group.CurrentRound + 1
	nextContributionDate := time.Now().AddDate(0, 0, group.ContributionPeriod)

	// Update group
	if err := database.DB.Model(&group).Updates(map[string]interface{}{
		"current_round":          nextRound,
		"next_contribution_date": nextContributionDate,
	}).Error; err != nil {
		return fmt.Errorf("failed to update group round: %w", err)
	}

	// Mark current round as completed
	database.DB.Model(&models.RoundStatus{}).
		Where("group_id = ? AND round = ?", group.ID, group.CurrentRound).
		Updates(map[string]interface{}{
			"status":           "completed",
			"payout_completed": true,
		})

	// Notify all members about new round
	var members []models.Member
	database.DB.Where("group_id = ? AND status = ?", group.ID, "approved").Find(&members)

	for _, member := range members {
		CreateNotification(
			member.UserID,
			group.ID,
			"new_round_started",
			"New Contribution Round Started",
			fmt.Sprintf("Round %d has started. Next contribution due: %s", 
				nextRound, nextContributionDate.Format("Jan 2, 2006")),
		)
	}

	fmt.Printf("‚úÖ Group %s advanced to round %d\n", group.Name, nextRound)
	return nil
}

// GetDesignatedAdmin returns the admin responsible for approving payouts
func (aps *AutomatedPayoutService) GetDesignatedAdmin(groupID string) (models.Member, error) {
	// Priority: Creator first, then oldest admin
	var admin models.Member
	
	// Try to get creator first
	if err := database.DB.Where("group_id = ? AND role = ? AND status = ?", 
		groupID, "creator", "approved").
		Preload("User").
		First(&admin).Error; err == nil {
		return admin, nil
	}

	// Fallback to oldest admin
	if err := database.DB.Where("group_id = ? AND role = ? AND status = ?", 
		groupID, "admin", "approved").
		Preload("User").
		Order("joined_at ASC").
		First(&admin).Error; err != nil {
		return models.Member{}, fmt.Errorf("no designated admin found")
	}

	return admin, nil
}

// ProcessPendingPayouts processes all pending automatic payouts
func (aps *AutomatedPayoutService) ProcessPendingPayouts() error {
	fmt.Println("üîÑ Processing pending automatic payouts...")

	var pendingPayouts []models.PayoutRequest
	if err := database.DB.Where("status = ? AND auto_generated = ?", "pending", true).
		Preload("Group").
		Preload("Recipient").
		Find(&pendingPayouts).Error; err != nil {
		return fmt.Errorf("failed to fetch pending payouts: %w", err)
	}

	fmt.Printf("üìã Found %d pending automatic payouts\n", len(pendingPayouts))

	for _, payout := range pendingPayouts {
		if err := aps.checkPayoutReadiness(payout); err != nil {
			fmt.Printf("‚ö†Ô∏è Payout %s not ready: %v\n", payout.ID, err)
			continue
		}
	}

	return nil
}

// checkPayoutReadiness checks if a payout is ready for execution
func (aps *AutomatedPayoutService) checkPayoutReadiness(payout models.PayoutRequest) error {
	// Check if admin has approved
	var approvalCount int64
	database.DB.Model(&models.PayoutApproval{}).
		Where("payout_request_id = ? AND approved = ?", payout.ID, true).
		Count(&approvalCount)

	if approvalCount == 0 {
		return fmt.Errorf("no admin approval yet")
	}

	fmt.Printf("‚úÖ Payout %s has admin approval, ready for execution\n", payout.ID)
	return nil
}

// ExecuteAutomaticPayout executes an approved automatic payout
func (aps *AutomatedPayoutService) ExecuteAutomaticPayout(payoutID, adminSecretKey string) error {
	fmt.Printf("üöÄ Executing automatic payout: %s\n", payoutID)

	// Get payout details
	var payout models.PayoutRequest
	if err := database.DB.Where("id = ?", payoutID).
		Preload("Group").
		Preload("Recipient").
		First(&payout).Error; err != nil {
		return fmt.Errorf("payout not found: %w", err)
	}

	// Validate payout is ready for execution
	if payout.Status != "pending" {
		return fmt.Errorf("payout is not in pending status: %s", payout.Status)
	}

	if !payout.AutoGenerated {
		return fmt.Errorf("this function only handles automatic payouts")
	}

	// Validate admin secret key
	if err := aps.validateAdminKey(payout.GroupID, adminSecretKey); err != nil {
		return fmt.Errorf("admin validation failed: %w", err)
	}

	// Execute the payout transaction
	txHash, err := aps.executePayoutTransaction(payout, adminSecretKey)
	if err != nil {
		// Mark payout as failed
		database.DB.Model(&payout).Updates(map[string]interface{}{
			"status": "failed",
		})
		return fmt.Errorf("payout execution failed: %w", err)
	}

	// Update payout as completed
	now := time.Now()
	database.DB.Model(&payout).Updates(map[string]interface{}{
		"status":       "completed",
		"tx_hash":      txHash,
		"completed_at": &now,
	})

	// Advance to next round
	if err := aps.advanceToNextRound(payout.Group); err != nil {
		fmt.Printf("‚ö†Ô∏è Warning: Failed to advance round: %v\n", err)
	}

	// Notify all members about successful payout
	aps.notifyPayoutCompletion(payout)

	fmt.Printf("‚úÖ Automatic payout executed successfully: %s\n", txHash)
	return nil
}

// validateAdminKey validates that the provided secret key belongs to a designated admin
func (aps *AutomatedPayoutService) validateAdminKey(groupID, secretKey string) error {
	// Import keypair package
	kp, err := keypair.ParseFull(secretKey)
	if err != nil {
		return fmt.Errorf("invalid secret key format")
	}

	// Parse the secret key to get public address

	// Check if this address belongs to a designated admin
	var admin models.Member
	if err := database.DB.Where("group_id = ? AND role IN ? AND status = ?", 
		groupID, []string{"creator", "admin"}, "approved").
		Preload("User").
		First(&admin).Error; err != nil {
		return fmt.Errorf("no admin found")
	}

	// Get user by wallet address
	var user models.User
	if err := database.DB.Where("wallet = ?", kp.Address()).First(&user).Error; err != nil {
		return fmt.Errorf("wallet address not found in system")
	}

	// Check if this user is the designated admin
	if user.ID != admin.UserID {
		return fmt.Errorf("provided key does not belong to designated admin")
	}

	return nil
}

// executePayoutTransaction performs the actual blockchain transaction
func (aps *AutomatedPayoutService) executePayoutTransaction(payout models.PayoutRequest, adminSecretKey string) (string, error) {
	fmt.Printf("üí∏ Executing payout transaction: %.2f XLM to %s\n", 
		payout.Amount, payout.Recipient.Wallet)

	// Method 1: Direct XLM transfer from group wallet to recipient
	if payout.Group.SecretKey != "" {
		tx, err := SendXLM(payout.Group.SecretKey, payout.Recipient.Wallet, 
			fmt.Sprintf("%.7f", payout.Amount))
		if err != nil {
			return "", fmt.Errorf("direct XLM transfer failed: %w", err)
		}
		return tx.Hash, nil
	}

	// Method 2: Use admin key to transfer from group wallet (if group secret not available)
	// This would require the admin to have control over group funds
	// For security, we'll require the group secret key
	return "", fmt.Errorf("group secret key required for payout execution")
}

// notifyPayoutCompletion notifies all members about completed payout
func (aps *AutomatedPayoutService) notifyPayoutCompletion(payout models.PayoutRequest) {
	var members []models.Member
	database.DB.Where("group_id = ? AND status = ?", payout.GroupID, "approved").Find(&members)

	for _, member := range members {
		var message string
		if member.UserID == payout.RecipientID {
			message = fmt.Sprintf("Congratulations! You received %.2f XLM from round %d", 
				payout.Amount, payout.Round)
		} else {
			message = fmt.Sprintf("Round %d payout of %.2f XLM has been sent to %s", 
				payout.Round, payout.Amount, payout.Recipient.Name)
		}

		CreateNotification(
			member.UserID,
			payout.GroupID,
			"payout_completed",
			"Payout Completed",
			message,
		)
	}
}

// StartAutomatedPayoutWorker starts a background worker to check for automatic payouts
func StartAutomatedPayoutWorker() {
	aps := &AutomatedPayoutService{}
	
	// Run every 5 minutes
	ticker := time.NewTicker(5 * time.Minute)
	go func() {
		for range ticker.C {
			if err := aps.CheckAndCreateAutomaticPayouts(); err != nil {
				fmt.Printf("‚ùå Automated payout worker error: %v\n", err)
			}
		}
	}()
	
	fmt.Println("ü§ñ Automated payout worker started (checking every 5 minutes)")
}